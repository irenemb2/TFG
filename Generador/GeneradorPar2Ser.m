function [] = GeneradorPar2Ser()
        name = sprintf('PAR2SER.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid, '--------------------------MODULO PAR2SER------------------------------------\n');
        fprintf(fid, '--Este modulo se encarga de transformar la señal que entra en paralelo en un pulso en serie\n');
        fprintf(fid, '--El pulso de salida informa sobre si la señal es 0, si es positiva o negativa y de su valor.\n');
        fprintf(fid, '--El primer pulso que coincide con count = 0 indica si la señal es nula o no, el segundo con count = 1 indica si la señal es positiva/negativa\n');
        fprintf(fid, '--El resto del pulso será 1 mientras sea mayor que la señal count y a 0 el resto del tiempo\n');
        fprintf(fid, '--ENTRADAS\n');
        fprintf(fid, '--data_in: señal a transformar\n');
        fprintf(fid, '--count: contador que utilizamos para comparar la señal y así codificarla\n');
        fprintf(fid, '--SALIDAS\n');
        fprintf(fid, '--data_out: manda la salida en serie\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity PAR2SER is\n');
        fprintf(fid, '\t Port (data_in : in STD_LOGIC_VECTOR(input_size - 1 downto 0);\n');
        fprintf(fid, '\t\t    count : in STD_LOGIC_VECTOR( input_size downto 0);\n');
        fprintf(fid, '\t\t    serial_out : out STD_LOGIC);\n');
        fprintf(fid, 'end PAR2SER; \n');
        fprintf(fid, 'architecture Behavioral of PAR2SER is\n');
        fprintf(fid, 'signal data_extended : unsigned(input_size downto 0) := (others=>''0'');\n');
        fprintf(fid, 'signal data : unsigned(input_size - 1 downto 0);\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'process(count, data_in, data_extended)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'if(count = "000000000" ) then \n');
        fprintf(fid, '\t if(data_in = "00000000") then\n');
        fprintf(fid, '\t\t serial_out <= ''0'';\n');
        fprintf(fid, '\telse\n');
        fprintf(fid, '\t\t serial_out <= ''1'';\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'elsif (count = "000000001" ) then   --cuando count es 1 mandamos 0 si el dato es positivo y 1 en caso contrario, el dato se pasa a valor absoluto\n');
        fprintf(fid, '\t if(data_in(input_size - 1) = ''0'') then\n');
        fprintf(fid, '\t \t serial_out <= ''0'';\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t serial_out <= ''1'';\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'else                                 --para los demas valores de count mandamos un pulso correspondiente al dato de enrada + 2 para compensar por count = 0 y count = 1\n');
        fprintf(fid, '\t if(data_extended > unsigned(count)) then\n');
        fprintf(fid, '\t \t serial_out <=''1'';\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t serial_out <=''0'';\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process (data_in)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '\t if(data_in(input_size - 1) = ''0'') then\n');
        fprintf(fid, '\t\t data <= unsigned(data_in);\n');
        fprintf(fid, '\t elsif(data_in = "10000000") then\n');
        fprintf(fid, '\t \t data<= "01111111";\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t  data<= unsigned(not(data_in)) + 1;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'data_extended <= unsigned(''0'' & data) + 2;\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
           
end

