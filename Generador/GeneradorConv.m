function [] = GeneradorConv()
        name = sprintf('CONV.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid, '--------------------------MODULO CONV------------------------------------\n');
        fprintf(fid, '--Este modulo realiza la función de convolución que cosiste en la suma de cada multiplicación de una señal por su peso correspondiente\n');
        fprintf(fid, '--según en que posición de la ventana del filtro se encuentr, se realiza sumando un 1 cada vez que el pulso de entrada indique que la señal no \n');
        fprintf(fid, '--es nula. Además si el pulso de entrada indica que la señal es negativa se invertirá el peso.\n');
        fprintf(fid, '---ENTRADAS\n');
        fprintf(fid, '-- data_in : los datos de entrada uno por uno como un pulso en serie\n');
        fprintf(fid, '-- cont_s : indica si el pulso recibido es la señal, si es 0 o si es negativa/positiva\n');
        fprintf(fid, '-- mul : indica en que parte del filtro nos encontramos, tendrá tamaño conv_col * conv_row * number_of_layers\n');
        fprintf(fid, '-- weight : peso correspondiente a la parte del filtro en la que nos encontremos\n');
        fprintf(fid, '-- next_pipeline_step : notifica de cuando termina una pasada del filtro y se pasa a la siguiente\n');
        fprintf(fid, '---SALIDAS\n');
        fprintf(fid, '--data_out : como salida se produce la acumulación de las señales de entrada multiplicadas por sus respectivos filtros\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity CONV is\n');
        fprintf(fid, '\t Port (data_in : in std_logic;\n');
        fprintf(fid, '\t\t    clk : in std_logic;\n');
        fprintf(fid, '\t\t    reset : in std_logic;\n');
        fprintf(fid, '\t\t    cont_s : in unsigned(1 downto 0);\n');
        fprintf(fid, '\t\t    next_pipeline_step : in std_logic;\n');
        fprintf(fid, '\t\t    weight : in STD_LOGIC_VECTOR(weight_size - 1 downto 0);\n');
        fprintf(fid, '\t\t    data_out : out STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0));\n');
        fprintf(fid, 'end CONV; \n');
        fprintf(fid, 'architecture Behavioral of CONV is\n');
        fprintf(fid, 'signal cero: STD_LOGIC := ''0'';\n');
        fprintf(fid, 'signal mac_out_next, mac_out_reg : signed(input_size+weight_size + 3 -1 downto 0) := (others => ''0'');\n');
        fprintf(fid, 'signal mux_out, mux_aux1, mux_aux : signed (weight_size-1 downto 0);\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'process(clk)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'if rising_edge(clk) then\n');
        fprintf(fid, '\t if (reset = ''1'') then\n');
        fprintf(fid, '\t\tmac_out_reg <= (others => ''0'');\n');
        fprintf(fid, '\telse\n');
        fprintf(fid, '\t\t mac_out_reg <= mac_out_next;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process (data_in, cont_s)         --si la señal cont_s es 0, el contador es 0 y el bit entrante indica si el dato tiene valor nulo \n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '\t cero <= ''0'';\n');
        fprintf(fid, '\t if(cont_s = 0) then\n');
        fprintf(fid, '\t \t if (data_in = ''0'') then\n');
        fprintf(fid, '\t \t \t cero <= ''1''; \n');
        fprintf(fid, ' \t \t end if; \n');
        fprintf(fid, '\t end if; \n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process (data_in, weight, cont_s)    --si la señal cont_s es 1, el contador es 1 y el bit entrante indica si el dato es positivo o negativo, en cuyo caso invertimos el peso\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'if(cont_s = 1 and data_in = ''1'' ) then\n');
        fprintf(fid, '\t mux_aux1 <= not(signed(weight)) + 1;\n');
        fprintf(fid, 'else\n');
        fprintf(fid, '\t mux_aux1 <= signed(weight); \n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process (cont_s, data_in, mux_aux1)    --si la señal cont_s es 2 todos los demas bits entrantes del dato son el valor numerico del mismo, si es 1 sumamos el peso\n');
        fprintf(fid, 'begin \n');
        fprintf(fid, '\t if(cont_s = 2) then \n');
        fprintf(fid, '\t \t if(data_in = ''1'') then\n');
        fprintf(fid, '\t \t \t mux_aux <= mux_aux1;\n');
        fprintf(fid, '\t \t else\n');
        fprintf(fid, '\t \t \t  mux_aux<= (others => ''0'');\n');
        fprintf(fid, '\t \t end if;\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t mux_aux<= (others => ''0'');\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process(mac_out_reg, cont_s, mux_out, next_pipeline_step)   --si la señal next-pipeline_step esta activa reseteamos el registro, si no lo es acumulamos el valor de las sumas\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '\t if (next_pipeline_step = ''1'') then\n');
        fprintf(fid, '\t \t mac_out_next <= (others => ''0'');\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t if(cont_s = 2) then \n');
        fprintf(fid, '\t \t \t  mac_out_next <= mac_out_reg + mux_out;\n');
        fprintf(fid, '\t \t else\n');
        fprintf(fid, '\t \t \t mac_out_next <= mac_out_reg;\n');
        fprintf(fid, '\t \t end if;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'mux_out <= "00000000" when (cero = ''1'') else mux_aux;   --si el dato entrante es 0 asignamos al resultado el valor 0 directamente\n');
        fprintf(fid, 'data_out <= std_logic_vector(mac_out_reg);\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
           
end

