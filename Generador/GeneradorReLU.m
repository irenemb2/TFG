function [] = GeneradorReLU()
        name = sprintf('RELU.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid, '--------------------------MODULO RELU------------------------------------\n');
        fprintf(fid, '--Este modulo se encarga de realizar la operación de ReLU, almacena los datos necesarios para la capa Pool del próximo filtro y suma el termino de bias\n');
        fprintf(fid, '--Los datos se almacenan si una vez sumado el termino de bias el resultado es positivo, si es negativo se almacena un cero en su lugar\n');
        fprintf(fid, '--ENTRADAS\n');
        fprintf(fid, '--data_in : como entrada recibe la salida de la operación convolucional\n');
        fprintf(fid, '--bias_term : recibe el termino bias de cada filtro porque realizamos la suma de este en la ReLU\n');
        fprintf(fid, '--index : esta señal sirve para transmitir todos los datos almacenados desde la relu a la próxima capa, cuando haya que procesarlos\n');
        fprintf(fid, '--SALIDAS\n');
        fprintf(fid, '--data_out : manda las señales almacenadas con el termino de bias y la ReLU aplicadas, una vez la siguiente capa notifique que las puede procesar\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity RELU is\n');
        fprintf(fid, '\t Port (clk : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    rst : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    next_pipeline_step : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    index : in std_logic;\n');
        fprintf(fid, '\t\t    data_in : in STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0);\n');
        fprintf(fid, '\t\t    bias_term : in unsigned (input_size + weight_size + 3 -1  downto 0);\n');
        fprintf(fid, '\t\t    data_out : out STD_LOGIC_VECTOR(input_size + weight_size + 3 -1  downto 0));\n');
        fprintf(fid, 'end RELU; \n');
        fprintf(fid, 'architecture Behavioral of RELU is\n');
        fprintf(fid, 'signal c_aux  :unsigned(input_size + weight_size + 3 downto 0) := (others => ''0'');\n');
        fprintf(fid, 'signal dato_reg : vector_relu(0 to pool2_size - 1);\n');
        fprintf(fid, 'signal dato_next : vector_relu(0 to pool2_size - 1);\n');
        fprintf(fid, 'signal index2 : natural := 0;\n');
        fprintf(fid, 'signal suma : unsigned(2 downto 0) := "000";\n');     
        fprintf(fid, 'begin\n');
        fprintf(fid, 'process(clk,rst)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'if (rst = ''1'') then  \n');
        fprintf(fid, '\t for i in 0 to pool2_size - 1 loop\n');
        fprintf(fid, '\t\t dato_reg(i) <= (others=>''0'');\n');
        fprintf(fid, '\t end loop;\n');
        fprintf(fid, 'elsif (clk''event and clk = ''1'') then \n');
        fprintf(fid, '\t if(index = ''1'') then          --si index = 1 incrementamos index2 para mandar por data_out los datos guardados en ReLu \n');
        fprintf(fid, '\t \t if(index2 = pool2_size - 1) then\n');
        fprintf(fid, '\t \t \t index2 <= 0;\n');
        fprintf(fid, '\t \t  else\n');
        fprintf(fid, '\t \t \t index2 <= index2 + 1;\n');
        fprintf(fid, '\t \t  end if;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, '\t if(next_pipeline_step = ''1'') then     --si next_pipeline_step se activa actualizamos el registro con un dato nuevo de la neurona \n');
        fprintf(fid, '\t \t  for i in 0 to pool2_size - 1 loop\n');
        fprintf(fid, '     \t \t \t dato_reg(i) <= dato_next(i);\n');
        fprintf(fid, '\t \t  end loop;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process(data_in, bias_term, c_aux, suma)          --si el dato es negativo se guarda un cero, en caso contrario guardamos el dato mas el bias term\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'c_aux <= (others => ''0''); \n');
        fprintf(fid, 'if((data_in(input_size + weight_size + 3 - 1 ) = ''0'') and (bias_term(input_size + weight_size + 3 - 1 ) = ''0'')) then\n');
        fprintf(fid, '\t c_aux <= (''0'' & unsigned(data_in)) + (''0'' & bias_term);\n');
        fprintf(fid, 'elsif((data_in(input_size + weight_size + 3 - 1 ) = ''1'') and (bias_term(input_size + weight_size + 3 - 1 ) = ''0'')) then;\n');
        fprintf(fid, '\t if(unsigned(data_in) < unsigned(bias_term)) then\n');
        fprintf(fid, '\t \t c_aux <= (''0'' & unsigned(data_in)) + (''0'' & bias_term);\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'elsif((data_in(input_size + weight_size + 3 - 1 ) = ''0'') and (bias_term(input_size + weight_size + 3 - 1 ) = ''1'')) then\n');
        fprintf(fid, '\t if(unsigned(data_in) > unsigned(bias_term)) then\n');
        fprintf(fid, '\t \t c_aux <= (''0'' & unsigned(data_in)) + (''0'' & bias_term);\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process(dato_reg, c_aux, dato_next)                   --guardamos los datos entrantes en registros consecutivos                               \n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'for i in pool2_size - 1 downto 0 loop\n');
        fprintf(fid, '\t if(i = pool2_size - 1) then\n');
        fprintf(fid, '  \t \t dato_next(i) <= std_logic_vector(c_aux(input_size + weight_size + 3 -1 downto 0));\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, 'dato_next(i) <= dato_reg(i + 1);\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end loop;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'data_out <= dato_reg(index2);\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
end

