function [] = GeneradorInterfazCapa1(capas)
        name = sprintf('Interfaz_ET1.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid,'--------------------MODULO INTERFAZ ETAPA1---------------------\n');
        fprintf(fid,'--Este modulo indica la dirección del dato de la RAM de entrada que necesitamos, el funcionamiento es identico\n');
        fprintf(fid,'--a las interfaces de las otras etapas pero en este caso también se calcula la dirección, además no mandamos dato_cero\n');
        fprintf(fid,'--por que el generador de esta etapa tendrá que procesaro un dato independientemente de si es cero o si proviene de la RAM\n');
        fprintf(fid,'--ENTRADAS\n');
        fprintf(fid,'--dato_in : señal que inidica la necesidad de calcular un nuevo dato en esta capa\n');
        fprintf(fid,'--poolx_col : señal que indica la posicion de las columnas del filtro pool de las capa siguientes, si no hay otra capa esta señal de entrada no existe\n');
        fprintf(fid,'--poolx_row : señal que indica la posicion de las filas del filtro pool de las capa siguientes, si no hay otra capa esta señal de entrada no existe\n');
        fprintf(fid,'--convx_col : señal que indica la posicion de las columnas del filtro de convolucion de la capa siguientes, si no hay otra capa esta señal de entrada no existe\n');
        fprintf(fid,'--convx_row : señal que indica la posicion de las filas del filtro de convolucion de la capa siguientes, si no hay otra capa esta señal de entrada no existe\n');
        fprintf(fid,'--SALIDAS\n');
        fprintf(fid,'--cero : señal que se mantiene a 1 o a cero dependiendo si el dato a procesar esta en zona padding o no, se le pasa a un multiplexador a la entrada del conversor par2ser\n');
        fprintf(fid,'--dato_out : señal que indica si es necesario un nuevo dato, se le pasa al generador de la capa anterior\n');
        fprintf(fid,'--address : dirección del dato necesario en la RAM\n');
        fprintf(fid,'library IEEE;\n');
        fprintf(fid,'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid,'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid,'entity INTERFAZ_ET1 is\n');
        fprintf(fid,'Port (clk : in STD_LOGIC;\n');
        fprintf(fid,'      reset : in STD_LOGIC;\n');
        fprintf(fid,'      dato_in : in std_logic;\n');
        for i = 2 : capas - 1
        fprintf(fid,'conv%d_col : in unsigned(log2c(conv%d_column) - 1 downto 0);\n', i, i);
        fprintf(fid,'conv%d_fila : in  unsigned(log2c(conv%d_row) - 1 downto 0);\n', i, i);
        fprintf(fid,'pool%d_col : in unsigned(log2c(pool%d_column) - 1 downto 0);\n', i+1, i+1);
        fprintf(fid,'pool%d_fila : in  unsigned(log2c(pool%d_row) - 1 downto 0);\n', i+1, i+1);
        end
        fprintf(fid,'dato_out : out std_logic;\n');
        fprintf(fid,'cero : out std_logic;\n');
        fprintf(fid,' address : out std_logic_vector(log2c(number_of_inputs + 1) - 1 downto 0));\n');
        fprintf(fid,'end Interfaz_ET1;\n');
        fprintf(fid,'architecture Behavioral of Interfaz_ET1 is\n');
         fprintf(fid,'type state_type is (idle , espera, s0, s1);\n');
        fprintf(fid,'signal state_reg, state_next : state_type;\n');
        fprintf(fid,'signal col_reg, col_next : unsigned(log2c(column_size + 2*(conv1_padding)) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal row_reg, row_next :  unsigned(log2c(row_size + 2*(conv1_padding)) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'--PRIMERA CAPA\n');
        fprintf(fid,'signal conv1_col_reg, conv1_col_next : unsigned(log2c(conv1_column) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal conv1_row_reg, conv1_row_next : unsigned(log2c(conv1_row) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal cuenta_capa_reg, cuenta_capa_next :  unsigned(log2c(number_of_layers1) - 1 downto 0) := (others => ''0'');\n');
        if (capas > 1) 
        fprintf(fid,'-- CAPA 2\n');
        fprintf(fid,'signal pool2_col_reg, pool2_col_next : unsigned(log2c(pool2_column) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal pool2_row_reg, pool2_row_next : unsigned(log2c(pool2_row) - 1 downto 0) := (others => ''0'');\n');    
        end
        fprintf(fid,'--REGISTROS\n');
        fprintf(fid,'signal address_reg , address_next :  unsigned(log2c(number_of_inputs + 1) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal address2_reg , address2_next :  unsigned(log2c(number_of_inputs + 1) - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid,'signal address2 : unsigned ( 11 downto 0):= (others => ''0'');\n');
        fprintf(fid,'signal primera_vuelta_reg, primera_vuelta_next, dato_out_reg, dato_out_next, cero_reg, cero_next : std_logic := ''0'';\n');
        fprintf(fid,'--CONSTANTES\n');
        fprintf(fid,'signal column_limit, row_limit : integer;\n');
        fprintf(fid,'begin\n');
        fprintf(fid,'process(clk, reset) \n');
        fprintf(fid,'begin \n');
        fprintf(fid,'if (reset = ''1'') then \n');
        fprintf(fid,'\t state_reg <= idle;\n');
        fprintf(fid,'elsif (clk''event and clk = ''1'') then \n');
        fprintf(fid,'\t state_reg <= state_next; \n');
        fprintf(fid,'\t col_reg <= col_next; \n');
        fprintf(fid,'\t row_reg <= row_next; \n');
        fprintf(fid,'\t pool2_col_reg <= pool2_col_next; \n');
        fprintf(fid,'\t pool2_row_reg <= pool2_row_next; \n');
        fprintf(fid,'\t conv1_col_reg <= conv1_col_next; \n');
        fprintf(fid,'\t conv1_row_reg <= conv1_row_next; \n');
        fprintf(fid,'\t cuenta_capa_reg <= cuenta_capa_next; \n');
        fprintf(fid,'\t address_reg <= address_next; \n');
        fprintf(fid,'\t address2_reg <= address2_next; \n');
        fprintf(fid,'\t primera_vuelta_reg <= primera_vuelta_next; \n');
        fprintf(fid,'\t dato_out_reg <= dato_out_next; \n');
        fprintf(fid,'\t cero_reg <= cero_next; \n');
        fprintf(fid,'end if; \n');
        fprintf(fid,'end process; \n');
        fprintf(fid, 'process (cero_reg, address_next, cuenta_capa_next, row_limit, column_limit,  address_reg, address2_reg, dato_out_reg,row_reg, col_reg, dato_in, cuenta_capa_reg, col_next, row_next, primera_vuelta_reg, state_reg, conv1_col_reg, conv1_row_reg, pool2_col_reg, pool2_row_reg ');
        for i = 2 : capas - 1
        fprintf(fid, ', conv%d_col', i);
        fprintf(fid, ', conv%d_fila', i);
        fprintf(fid, ', pool%d_col', i + 1);
        fprintf(fid, ', pool%d_fila', i + 1);
        end
        fprintf(fid,')\n');
        fprintf(fid,'variable stride1');
        for i = 2 : capas + +2
        fprintf(fid, ', stride%d',i);
        end
        fprintf(fid,' : natural;\n');
        fprintf(fid,'variable col_resta1 ');
        for i = 2 : capas + 2
        fprintf(fid, ', col_resta%d',i);
        end
        fprintf(fid,' : natural;\n');
        fprintf(fid,'variable row_resta1 ');
        for i = 2 : capas + 2
        fprintf(fid, ', row_resta%d',i);
        end
        fprintf(fid,' : natural;\n');
        fprintf(fid,'begin\n');
        fprintf(fid,'state_next <= state_reg;\n');
        fprintf(fid,'col_next <= col_reg;\n');
        fprintf(fid,'row_next <= row_reg;\n');
        fprintf(fid,'conv1_col_next <= conv1_col_reg;\n');
        fprintf(fid,'conv1_row_next <= conv1_row_reg;\n');
        fprintf(fid,'cuenta_capa_next <= cuenta_capa_reg;\n');
        fprintf(fid,'pool2_col_next <= pool2_col_reg;\n');
        fprintf(fid,'pool2_row_next <= pool2_row_reg;\n');
        fprintf(fid,'address_next <= address_reg;\n');
        fprintf(fid,'address2_next <= address2_reg;\n');
        fprintf(fid,'primera_vuelta_next <= primera_vuelta_reg;\n');
        fprintf(fid,'dato_out_next <= dato_out_reg;\n');
        fprintf(fid,'cero_next <= cero_reg;\n');
        fprintf(fid,' case state_reg is \n');
        fprintf(fid,' when idle =>  \n');
        fprintf(fid,'\t col_next  <= (others => ''0'');\n');
        fprintf(fid,'\t row_next  <= (others => ''0'');\n');
        fprintf(fid,'\t conv1_col_next <= (others => ''0'');\n');
        fprintf(fid,'\t conv1_row_next  <= (others => ''0'');\n');
        fprintf(fid,'\t cuenta_capa_next  <= (others => ''0'');\n');
        fprintf(fid,'\t pool2_col_next  <= (others => ''0'');\n');
        fprintf(fid,'\t pool2_row_next  <= (others => ''0'');\n');
        fprintf(fid,'\t address_next  <= (others => ''0'');\n');
        fprintf(fid,'\t address2_next  <= (others => ''0'');\n');
        fprintf(fid,'\t cero_next <= ''0'';\n');
        fprintf(fid,'\t primera_vuelta_next <= ''0''; \n');
        fprintf(fid,'\t dato_out_next <= ''0'';\n');
        fprintf(fid,'\t state_next <= espera;\n');
        fprintf(fid,'when espera => \n');
        fprintf(fid,'\t dato_out_next <= ''0'';\n');
        fprintf(fid,'\t if(dato_in = ''1'') then\n');
        fprintf(fid,'\t \t state_next <= s0;\n');
        fprintf(fid,'\t end if;\n');
        fprintf(fid,'when s0 => \n');
        fprintf(fid,'dato_out_next <= ''0'';\n');
        fprintf(fid,'if(primera_vuelta_reg = ''0'') then\n');
        fprintf(fid,'   primera_vuelta_next <= ''1'';\n');
        fprintf(fid,'   state_next <= s1;\n');
        fprintf(fid,'   cero_next <= ''1'';\n');
        fprintf(fid,'else\n');
        fprintf(fid,'  if (conv1_col_reg /= conv1_column - 1) then\n');
        fprintf(fid,'    stride1 := 1;\n');
        fprintf(fid,'    col_resta1 := conv1_column-1;\n');
        fprintf(fid,'    row_resta1 := conv1_row - 1;\n');
        fprintf(fid,'    col_next <= col_reg + stride1;\n');
        fprintf(fid,'    conv1_col_next <= conv1_col_reg + 1;\n');
        fprintf(fid,'    address_next <= address_reg + stride1; \n');
        fprintf(fid,'else\n');
        fprintf(fid,'   conv1_col_next <= (others => ''0'');\n');
        fprintf(fid,'   if (conv1_row_reg /= (conv1_row - 1)) then    --si no ha terminado de recorrer el tamaño del filtro sumamos uno a la fila y devolvemos el valor original a las columnas\n');
        fprintf(fid,'      col_next <= col_reg - col_resta1;\n');
        fprintf(fid,'      row_next <= row_reg + stride1;\n');
        fprintf(fid,'      conv1_row_next <= conv1_row_reg + 1;\n');
        fprintf(fid,'      address_next <= address_reg - col_resta1 + stride1*row_size;\n');
        fprintf(fid,'   else\n');
        fprintf(fid,'     conv1_row_next <= (others => ''0''); \n');
        fprintf(fid,'     if(cuenta_capa_reg /= number_of_layers1 - 1) then \n');
        fprintf(fid,'        address_next <= address_reg - (row_size * row_resta1 ) - col_resta1;\n');
        fprintf(fid,'        cuenta_capa_next <= cuenta_capa_reg + 1;  \n');
        fprintf(fid,'        col_next <= col_reg - col_resta1;\n');
        fprintf(fid,'        row_next<= row_reg - row_resta1;\n');
        fprintf(fid,'     else\n');
        fprintf(fid,'cuenta_capa_next <=(others => ''0'');\n');
        fprintf(fid,'if (pool2_col_reg /= pool2_column - 1) then      --si ha terminado de recorrer el tamaño del filtro en todas las capas, avanzamos el filtro un valor = a stride, tantas veces como columnas tenga el filtro siguiente\n');
        fprintf(fid,' row_next <= row_reg- row_resta1;\n');
        fprintf(fid,' col_next <= col_reg- col_resta1 + stride1;\n');
        fprintf(fid,'pool2_col_next <= pool2_col_reg + 1;\n');
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta1 ) - col_resta1 + stride1;\n');
        fprintf(fid,'else\n');
        fprintf(fid,' pool2_col_next <= (others => ''0'');\n');
        fprintf(fid,'if (pool2_row_reg /= (pool2_row - 1)) then    --si no ha terminado de recorrer el tamaño del filtro sumamos stride a las filas y devolvemos el valor original a las columnas\n');
        fprintf(fid,'col_resta2 := col_resta1 + (stride1 * (pool2_column - 1));\n');
        fprintf(fid,'row_next <= row_reg- row_resta1 + stride1;\n');
        fprintf(fid,' col_next <= col_reg- col_resta2;    -- restamos las columnas del filtro actual * el stride del filtro anterior = (numero total de columnas recorridas)\n');
        fprintf(fid,'pool2_row_next <= pool2_row_reg + 1;\n');
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta ) - col_resta2 + (row_size * stride1 );\n');
        fprintf(fid,' else\n');
        for i = 2 : capas - 1
        fprintf(fid,'pool%d_row_next <= (others => ''0'');\n', i);
        fprintf(fid,'row_resta%d := row_resta%d + (stride%d * (pool%d_row - 1));\n', i, i-1, i-1, i);
        fprintf(fid,'if (conv%d_col /= conv%d_column - 1) then\n', i, i);
        fprintf(fid,'  stride%d := stride%d * pool%d_stride;\n', i, i-1, i);
        fprintf(fid,'row_next <= row_reg - row_resta%d;\n', i);
        fprintf(fid,'col_next <= col_reg - col_resta%d + stride%d\n', i , i );
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta%d ) - col_resta%d + stride%d;\n', i, i, i);
        fprintf(fid,'else\n');
        fprintf(fid,'if (conv%d_fila /= (conv%d_row - 1)) then\n', i, i);
        fprintf(fid,'col_resta%d:= col_resta%d + (stride%d * (conv%d_column-1));\n', i+1, i, i, i);
        fprintf(fid,'row_next <= row_reg - row_resta%d + stride%d;\n', i,i);
        fprintf(fid,'col_next <= col_reg - col_resta%d;\n', i);
        fprintf(fid,' address_next <= address_reg - (row_size * row_resta%d ) - col_resta%d   + (row_size*stride%d);\n', i, i+1, i+1);
        fprintf(fid,'else\n');
        fprintf(fid,'row_resta%d := row_resta%d + (stride%d * (conv%d_row-1));\n', i +1 , i, i, i);
        fprintf(fid,'if (pool%d_col /= pool%d_column - 1) then\n', i+1, i+1);
        fprintf(fid,'stride%d := stride%d * conv%d_stride; \n', i+1, i, i);
        fprintf(fid,' row_next <= row_reg- row_resta%d;\n', i +1);
        fprintf(fid,' col_next <= col_reg - col_resta%d + stride%d;\n', i + 1, i + 1);
        fprintf(fid,'address_next <=  address_reg - (row_size * row_resta%d ) - col_resta%d + stride%d;\n', i + 1, i + 1, i + 1);
        fprintf(fid,' else\n');
        fprintf(fid,' if (pool%d_fila /= (pool%d_row - 1)) then \n', i + 1, i + 1);
        fprintf(fid,'col_resta%d:= col_resta%d + (stride%d * (pool%d_column-1));\n',i + 2, i + 1, i + 1, i + 1);
        fprintf(fid,' row_next <= row_reg - row_resta%d + stride%d;\n', i + 1, i + 1);
        fprintf(fid,'col_next <= col_reg - col_resta%d;\n', i + 2);
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta%d ) - col_resta%d  + (row_size*stride%d);\n' , i +1, i+2, i+1);
        fprintf(fid,' else\n');
        fprintf(fid,'row_resta%d := row_resta%d + (stride%d * (pool%d_row - 1));\n',i + 2, i+1, i+1, i+1 );
        end
        fprintf(fid,'if(col_reg /= column_limit - 1) then\n');
        fprintf(fid,'stride%d := stride%d * pool%d_stride;\n', capas + 2, capas + 1, capas);
        fprintf(fid,'row_next <= row_reg - row_resta%d;\n', capas + 2);
        fprintf(fid,'col_next <= col_reg- col_resta%d + stride%d;\n', capas + 2);
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta%d ) - col_resta%d  + stride%d;\n', capas + 2, capas + 2, capas + 2);
        fprintf(fid,'else \n');
        fprintf(fid,' row_next <= row_reg - row_resta%d + stride%d;\n', capas + 2, capas + 2);
        fprintf(fid,'col_next <= (others => ''0'');\n');
        fprintf(fid,'address_next <= address_reg - (row_size * row_resta%d) - col_resta%d  + (row_size*stride%d);\n', capas + 2, capas + 2, capas + 2);
        fprintf(fid,'if(row_reg = row_limit) then\n');
        fprintf(fid,'row_next <= (others => ''0'');\n');
        fprintf(fid,'address_next <=(others => ''0'');\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'end if;\n');
        for i = 1 : ((capas - 2) * 4) - 1
        fprintf(fid,'end if;\n');
        end
        fprintf(fid,'if(conv1_padding > col_next or col_next >= column_size + conv1_padding or conv1_padding > row_next or row_next >= column_size + conv1_padding ) then\n');
        fprintf(fid,'cero_next <= ''1'';\n');
        fprintf(fid,'else \n');
        fprintf(fid,'cero_next <= ''0'';\n');
        fprintf(fid,'address2_next <= address_next - (conv1_padding + (row_size * conv1_padding) + ( 2 * conv1_padding * (row_next - conv1_padding))) + (cuenta_capa_next & "0000000000");\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'state_next <= s1;\n');
        fprintf(fid,'end if;\n');
        fprintf(fid,'when s1 =>\n');
        fprintf(fid,'state_next <= espera;\n');
        fprintf(fid,'dato_out_next <= ''1'';\n');
        fprintf(fid,'end case;\n');
        fprintf(fid,'end process;\n');
        fprintf(fid,'column_limit<= column_size + 2*(conv1_padding);    --tenemos en cuenta el padding para los valores limites de columnas y filas\n');
        fprintf(fid,'row_limit<= row_size  + 2*(conv1_padding);\n');
        fprintf(fid,'address <= std_logic_vector(address2_reg);\n');
        fprintf(fid,'dato_out <= dato_out_reg;\n');
        fprintf(fid,'cero <= cero_reg;\n');
        fprintf(fid,'end Behavioral;\n');
        fclose(fid);
end

