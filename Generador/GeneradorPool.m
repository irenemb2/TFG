function [] = GeneradorPool()
  name = sprintf('MAXPOOL.vhd');
        fid = fopen(name, 'wt');
        fprintf(fid, '--------------------------MODULO MAXPOOL------------------------------------\n');
        fprintf(fid, '--Este modulo va a realizar la operación de MaxPool, que consiste en calcular el máximo de un conjunto de datos.\n');
        fprintf(fid, '--Esto se consigue comparando la entrada con el dato ya registrado, si es mayor se almacena la entrada y si no se descarta, \n');
        fprintf(fid, '----la señal  se resetea cada vez que se guarden tantas entradas como dimensión tenga el filtro\n');
        fprintf(fid, '--ENTRADAS\n');
        fprintf(fid, '--data_in : dato procesado por la capa de convolución y relu, que proviene del multiplexador\n');
        fprintf(fid, '--next_dato_pool : señal que indica cuando ha terminado de procesarse una pasa de filtro\n');
        fprintf(fid, '--SALIDAS\n');
        fprintf(fid, '--data_out: señal de salida, sale una por cada pasada de filtro que corresponde con el dato más alto de los registrados\n');
        fprintf(fid, 'library IEEE;\n');
        fprintf(fid, 'use IEEE.STD_LOGIC_1164.ALL;\n');
        fprintf(fid, 'use work.tfg_irene_package.ALL;\n');
        fprintf(fid, 'use IEEE.NUMERIC_STD.ALL;\n');
        fprintf(fid, 'entity MAXPOOL is\n');
        fprintf(fid, '\t Port (clk : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    rst : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    next_dato_pool : in STD_LOGIC;\n');
        fprintf(fid, '\t\t    data_in : in STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0);\n');
        fprintf(fid, '\t\t    data_out : out STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0));\n');
        fprintf(fid, 'end MAXPOOL; \n');
        fprintf(fid, 'architecture Behavioral of MAXPOOL is\n');
        fprintf(fid, 'signal dato_reg, dato_reg2: STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid, 'signal dato_next: STD_LOGIC_VECTOR(input_size + weight_size + 3 - 1 downto 0) := (others => ''0'');\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'process(clk,rst)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, 'if (rst = ''1'') then  \n');
        fprintf(fid, '\t dato_reg <= (others=>''0'');\n');
        fprintf(fid, '\t dato_reg2 <= (others=>''0'');\n');
        fprintf(fid, 'elsif (clk''event and clk = ''1'') then \n');
        fprintf(fid, '\t  dato_reg <= dato_next; \n');
        fprintf(fid, '\t    if(next_dato_pool = ''1'') then     --cuando la señal pool del generador se activa mandamos el dato de salida\n');
        fprintf(fid, '\t \t dato_reg2 <= dato_reg;\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'process(dato_reg, data_in, next_dato_pool)\n');
        fprintf(fid, 'begin\n');
        fprintf(fid, '\t if(next_dato_pool = ''0'') then        --si la señal pool no esta a 1 comparamos los datos entrantes \n');
        fprintf(fid, '\t \t if(data_in > dato_reg) then          --si el dato entrante es mayor que el dato anterior lo registramos\n');
        fprintf(fid, '\t \t \t  dato_next <= data_in;\n');
        fprintf(fid, '\t \t else\n');
        fprintf(fid, '\t \t \t dato_next <= dato_reg;\n');
        fprintf(fid, '\t \t end if;\n');
        fprintf(fid, '\t else\n');
        fprintf(fid, '\t \t dato_next <= (others=>''0'');  --si la señal pool está activa mandamos le dato de salida y ponemos a 0 el registro\n');
        fprintf(fid, '\t end if;\n');
        fprintf(fid, 'end process;\n');
        fprintf(fid, 'data_out <= dato_reg2;\n');
        fprintf(fid, 'end Behavioral;\n');
        fclose(fid);
end

